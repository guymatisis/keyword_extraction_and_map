                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
                                                                      
          Figure 15-6. Time series forecasting                        
                                                                      
          For simplicity, we are using a time series generated by the generate_time_series()
          function, shown here:                                       
            def generate_time_series(batch_size, n_steps):            
               freq1, freq2, offsets1, offsets2 = np.random.rand(4, batch_size, 1)
               time = np.linspace(0, 1, n_steps)                      
               series = 0.5 * np.sin((time - offsets1) * (freq1 * 10 + 10)) # wave 1
               series += 0.2 * np.sin((time - offsets2) * (freq2 * 20 + 20)) # + wave 2
               series += 0.1 * (np.random.rand(batch_size, n_steps) - 0.5) # + noise
               return series[..., np.newaxis].astype(np.float32)      
          This function creates as many time series as requested (via the batch_size argu‐
          ment), each of length n_steps, and there is just one value per time step in each series
          (i.e., all series are univariate). The function returns a NumPy array of shape [batch
          size, time steps, 1], where each series is the sum of two sine waves of fixed amplitudes
          but random frequencies and phases, plus a bit of noise.     
                                                                      
                   When dealing with time series (and other types of sequences such
                   as sentences), the input features are generally represented as 3D
                   arrays of shape [batch size, time steps, dimensionality], where
                   dimensionality is 1 for univariate time series and more for multi‐
                   variate time series.                               
          Now let’s create a training set, a validation set, and a test set using this function:
                                                                      
            n_steps = 50                                              
            series = generate_time_series(10000, n_steps + 1)         
            X_train, y_train = series[:7000, :n_steps], series[:7000, -1]
            X_valid, y_valid = series[7000:9000, :n_steps], series[7000:9000, -1]
            X_test, y_test = series[9000:, :n_steps], series[9000:, -1]
          X_train contains 7,000 time series (i.e., its shape is [7000, 50, 1]), while X_valid con‐
          tains 2,000 (from the 7,000th time series to the 8,999th) and X_test contains 1,000
          (from the 9,000th to the 9,999th). Since we want to forecast a single value for each ser‐
          ies, the targets are column vectors (e.g., y_train has a shape of [7000, 1]).