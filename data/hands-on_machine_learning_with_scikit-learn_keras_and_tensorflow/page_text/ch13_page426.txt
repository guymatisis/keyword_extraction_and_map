                                                                      
                                                                      
                                                                      
                                                                      
          This definition says we are using version 3 of the protobuf format, and it specifies
          that each Person object6 may (optionally) have a name of type string, an id of type
          int32, and zero or more email fields, each of type string. The numbers 1, 2, and 3
          are the field identifiers: they will be used in each record’s binary representation. Once
          you have a definition in a .proto file, you can compile it. This requires protoc, the
          protobuf compiler, to generate access classes in Python (or some other language).
          Note that the protobuf definitions we will use have already been compiled for you,
          and their Python classes are part of TensorFlow, so you will not need to use protoc.
          All you need to know is how to use protobuf access classes in Python. To illustrate the
          basics, let’s look at a simple example that uses the access classes generated for the
          Person protobuf (the code is explained in the comments):    
                                                                      
            >>> from person_pb2 import Person # import the generated access class
            >>> person = Person(name="Al", id=123, email=["a@b.com"]) # create a Person
            >>> print(person) # display the Person                    
            name: "Al"                                                
            id: 123                                                   
            email: "a@b.com"                                          
            >>> person.name # read a field                            
            "Al"                                                      
            >>> person.name = "Alice" # modify a field                
            >>> person.email[0] # repeated fields can be accessed like arrays
            "a@b.com"                                                 
            >>> person.email.append("c@d.com") # add an email address 
            >>> s = person.SerializeToString() # serialize the object to a byte string
            >>> s                                                     
            b'\n\x05Alice\x10{\x1a\x07a@b.com\x1a\x07c@d.com'         
            >>> person2 = Person() # create a new Person              
            >>> person2.ParseFromString(s) # parse the byte string (27 bytes long)
            27                                                        
            >>> person == person2 # now they are equal                
            True                                                      
          In short, we import the Person class generated by protoc, we create an instance and
          play with it, visualizing it and reading and writing some fields, then we serialize it
          using the SerializeToString() method. This is the binary data that is ready to be
          saved or transmitted over the network. When reading or receiving this binary data,
          we can parse it using the ParseFromString() method, and we get a copy of the object
          that was serialized.7                                       
          We could save the serialized Person object to a TFRecord file, then we could load and
          parse it: everything would work fine. However, SerializeToString() and ParseFrom
          6 Since protobuf objects are meant to be serialized and transmitted, they are called messages.
          7 This chapter contains the bare minimum you need to know about protobufs to use TFRecords. To learn more
           about protobufs, please visit https://homl.info/protobuf.  