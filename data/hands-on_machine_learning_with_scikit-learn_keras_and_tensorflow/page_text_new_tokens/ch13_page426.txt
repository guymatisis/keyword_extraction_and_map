This definition says we are using version 3 of the protobuf format, and it specifies
that each Person object 6 may (optionally) have a name of type string , an id of type
int32 , and zero or more email fields, each of type string . The numbers 1 , 2 , and 3
are the field identifiers: they will be used in each record’s binary representation. Once
you have a definition in a <i>.proto</i> file, you can compile it. This requires protoc , the
protobuf compiler, to generate access classes in Python (or some other language).
Note that the protobuf definitions we will use have already been compiled for you,
protoc
and their Python classes are part of TensorFlow, so you will not need to use .
All you need to know is how to use protobuf access classes in Python. To illustrate the
basics, let’s look at a simple example that uses the access classes generated for the
Person
protobuf (the code is explained in the comments):
<b>>>></b> <b>from</b> <b>person_pb2</b> <b>import</b> Person <i>#</i> <i>import</i> <i>the</i> <i>generated</i> <i>access</i> <i>class</i>
<b>>>></b> person = Person(name="Al", id=123, email=["a@b.com"]) <i>#</i> <i>create</i> <i>a</i> <i>Person</i>
<b>>>></b> <b>print(person)</b> <i>#</i> <i>display</i> <i>the</i> <i>Person</i>
name: "Al"
id: 123
email: "a@b.com"
<b>>>></b> person.name <i>#</i> <i>read</i> <i>a</i> <i>field</i>
"Al"
<b>>>></b> person.name = "Alice" <i>#</i> <i>modify</i> <i>a</i> <i>field</i>
<b>>>></b> person.email[0] <i>#</i> <i>repeated</i> <i>fields</i> <i>can</i> <i>be</i> <i>accessed</i> <i>like</i> <i>arrays</i>
"a@b.com"
<b>>>></b> person.email.append("c@d.com") <i>#</i> <i>add</i> <i>an</i> <i>email</i> <i>address</i>
<b>>>></b> s = person.SerializeToString() <i>#</i> <i>serialize</i> <i>the</i> <i>object</i> <i>to</i> <i>a</i> <i>byte</i> <i>string</i>
<b>>>></b> s
b'\n\x05Alice\x10{\x1a\x07a@b.com\x1a\x07c@d.com'
<b>>>></b> person2 = Person() <i>#</i> <i>create</i> <i>a</i> <i>new</i> <i>Person</i>
<b>>>></b> person2.ParseFromString(s) <i>#</i> <i>parse</i> <i>the</i> <i>byte</i> <i>string</i> <i>(27</i> <i>bytes</i> <i>long)</i>
27
<b>>>></b> person == person2 <i>#</i> <i>now</i> <i>they</i> <i>are</i> <i>equal</i>
True
In short, we import the Person class generated by protoc , we create an instance and
play with it, visualizing it and reading and writing some fields, then we serialize it
SerializeToString()
using the method. This is the binary data that is ready to be
saved or transmitted over the network. When reading or receiving this binary data,
we can parse it using the ParseFromString() method, and we get a copy of the object
that was serialized.7
Person
We could save the serialized object to a TFRecord file, then we could load and
parse it: everything would work fine. However, SerializeToString() and ParseFrom
6 Sinceprotobufobjectsaremeanttobeserializedandtransmitted,theyarecalledmessages.
7 ThischaptercontainsthebareminimumyouneedtoknowaboutprotobufstouseTFRecords.Tolearnmore
aboutprotobufs,pleasevisithttps://homl.info/protobuf.